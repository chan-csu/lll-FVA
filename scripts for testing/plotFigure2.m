function ax = plotFigure2(testModel, testVector, testMethod, filePath, BW)
% This script is for plotting Figure 2 in the paper. It loads the data
% generated by test.m

% set the data to plot here
if nargin < 1 || isempty(testModel)
    % models tested (1 to 7)
    testModel = 1:3;
end
if nargin < 2 || isempty(testVector)
    % test data to be retrieved
    testVector = 1:3;
end
if nargin < 3 || isempty(testMethod)
    % methods tested
    testMethod = 1:4;
end
if nargin < 4 || isempty(filePath)
    % path to the data files
    filePath = [pwd filesep 'test_results' filesep 'testResult_'];
end
if nargin < 5 || isempty(BW)
    BW = 0;  % 1 for black and white; 0 for color
end

allMethod = {'ll-FVA', 'fastSNP', 'NS-LLC', 'EFM-LLC'};
method2Test = allMethod(testMethod);  % methods tested
%% get the list of models
d = dir([pwd filesep 'test_models']);
modelList = {};
modelSize = [];
for j = 1:numel(d)
    if ~strncmp(d(j).name(1), '.', 1) && ~strncmp(d(j).name, 'model', 5)
        modelList(end + 1) = {[pwd, filesep, 'test_models', filesep, d(j).name]};
        model = load(modelList{end});
        modelSize = [modelSize; size(model.model.S)];
    end
end

% start from easy models to difficult models
[~, ind] = sort(modelSize(:, 1) .* modelSize(:, 2));
modelList = modelList(ind)';
modelSize = modelSize(ind, :);
modelName = regexp(modelList, ['[^\' filesep ']+$'], 'match', 'once');

%% get the data
% preprocessing time    
res = struct();
field = {'ns', 'loopPreprocess', 'rxnLink', 'milp'};
for jF = 1:numel(field)
    res.([field{jF} 'CPU']) = zeros(numel(method2Test), numel(testModel), numel(testVector));
    res.([field{jF} 'Time']) = zeros(numel(method2Test), numel(testModel), numel(testVector));
end
res.milpVarCPU = cell(numel(method2Test), numel(testModel), numel(testVector));
res.milpVarTime = cell(numel(method2Test), numel(testModel), numel(testVector));
for j = 1:numel(testModel)
    for jT = 1:numel(testVector)
        for jM = 1:numel(method2Test)
            
            data = load([filePath 't' num2str(jT) '_m' num2str(testModel(j)) '_' method2Test{jM} '.mat']);
            for k = {'nsCPU', 'nsTime', 'loopPreprocessCPU', ...
                    'loopPreprocessTime', 'rxnLinkCPU', 'rxnLinkTime'}
                res.(k{:})(jM, j, jT) = data.resInfo.(k{:});
            end    
            for k = {'milpCPU', 'milpTime'}
                res.(k{:})(jM, j, jT) = sum(sum(data.resInfo.(k{:}))) ...
                    + sum(sum(data.resInfo.(strrep(k{:}, 'milp', 'lp'))));
            end
            res.wallTime(jM, j, jT) = data.wallTime;
            res.cpuTime(jM, j, jT) = data.cpuTime;
            milpVarTime = [];
            milpVarCPU = [];
            for k1 = 1:size(data.resInfo.milpTime, 1)
                for k2 = 1:2
                    if data.resInfo.lpTime(k1, k2) > 0
                        % LP solved in this case
                        milpVarTime(end + 1, :) = [data.resInfo.lpTime(k1, k2), 0];
                        milpVarCPU(end + 1, :) = [data.resInfo.lpCPU(k1, k2), 0];
                    elseif data.resInfo.milpTime(k1, k2) > 0
                        % MILP solved
                        milpVarTime(end + 1, :) = [data.resInfo.milpTime(k1, k2), data.resInfo.nBinVar(k1)];
                        milpVarCPU(end + 1, :) = [data.resInfo.milpCPU(k1, k2), data.resInfo.nBinVar(k1)];
                    else
                        error('Nothing solved?')
                    end
                end
            end
            res.milpVarCPU{jM, j, jT} = milpVarCPU;
            res.milpVarTime{jM, j, jT} = milpVarTime;
            
            res.fvaRange{jM, j, jT} = data.fvaRange;
            res.maxDiff(jM, j, jT) = max(max(abs(res.fvaRange{jM, j, jT} - res.fvaRange{1, j, jT})));
            tmp = abs(res.fvaRange{jM, j, jT}(:) - res.fvaRange{1, j, jT}(:));
            tmpL = max(abs(res.fvaRange{jM, j, jT}(:)), abs(res.fvaRange{1, j, jT}(:)));
            res.maxDiffPercent(jM, j, jT) = max(tmp(tmpL > 0) ./ tmpL(tmpL > 0));
        end
    end
end

%% get mean and sd
dataMean = struct();
dataSD = struct();
field = fieldnames(res);
for jF = 1:numel(field)
    if ~iscell(res.(field{jF}))
        dataMean.(field{jF}) = mean(res.(field{jF}), 3);
        dataSD.(field{jF}) = std(res.(field{jF}), [], 3);
    else
        dataMean.(field{jF}) = cell(size(res.(field{jF}), 1), size(res.(field{jF}), 2));
        dataSD.(field{jF}) = cell(size(res.(field{jF}), 1), size(res.(field{jF}), 2));
        for j1 = 1:size(res.(field{jF}), 1)
            for j2 = 1:size(res.(field{jF}), 2)
                tmp = [];
                for j3 = 1:size(res.(field{jF}), 3)
                    tmp = cat(3, tmp, res.(field{jF}){j1, j2, j3});
                end
                dataMean.(field{jF}){j1, j2} = mean(tmp, 3);
                dataSD.(field{jF}){j1, j2} = std(tmp, [], 3);
            end
        end
    end
end
barMatrix = [dataMean.nsCPU(:), dataMean.loopPreprocessCPU(:), dataMean.rxnLinkCPU(:), dataMean.milpCPU(:)];
% barMatrix = barMatrix([1:9 13:21 10:12], :);

%% plot the figures
clear p p2
f = figure;
f.Units = 'inches';

nMeth = numel(method2Test);
nModel = numel(testModel);
ax = subplot(2,1,1);
x = setdiff(1:((nMeth + 1) * nModel), (nMeth + 1):(nMeth + 1):((nMeth + 1)* nModel));
% x = [1:4, 5.5:1:8.5 10:13 14.5:1:17.5 19:22 23.5:1:26.5 28:31];
%x = setdiff(1:35, 5:5:35);
p = bar(x, barMatrix, 'stacked');
ax.YScale = 'log';

leg = {sprintf('Nullspace calculation'), ...
    sprintf('LLC preprocessing'), sprintf('EFM computation'), ...
    sprintf('MILP solution')};
lg = legend(leg);   
lg.Position = [0.78 0.8 0.2 0.2];
ax.XTick = x;
ax.XTickLabel = repmat(method2Test, 1, numel(testModel));
ax.XTickLabelRotation = 90;
ax.Box = 'off';
ax.YMinorTick = 'off';
yl = ylabel('Total CPU time (sec)');
ax(1).XLim = [0, x(end) + 1];
ax(1).YLim = 10.^[-2.5, 5];
ax(1).YTick = 10.^[-3:5];
ax.Color = 'none';


ax(2) = subplot(2,1,2);
clear val
interval = [...
    0   0; ...
    0   50; ...
    50  100; ...
    100 100; ...
    ] / 100;
sgn = {...
    'Eq', 'Eq'; ...
    'Gt', 'Le'; ...
    'Gt', 'Lt'; ...
    'Eq', 'Eq'; ...
    };
leg2 = {'$f = 0$'; '$0 < f \leq 0.5$'; '$0.5 < f < 1$'; '$f = 1$'};

for j = 1:nModel
    nBinmax = max(dataMean.milpVarCPU{1, j}(:, 2));
    
    for m = 1:nMeth
        for k1 = 1:size(interval, 1)
            select = true(size(dataMean.milpVarCPU{m, j}, 1), 1);
            for k2 = 1:size(interval, 2)
                switch sgn{k1, k2}
                    case 'Eq'
                        select = select & dataMean.milpVarCPU{m, j}(:, 2) == nBinmax * interval(k1, k2);
                    case 'Gt'
                        select = select & dataMean.milpVarCPU{m, j}(:, 2) > nBinmax * interval(k1, k2);
                    case 'Ge'
                        select = select & dataMean.milpVarCPU{m, j}(:, 2) >= nBinmax * interval(k1, k2);
                    case 'Lt'
                        select = select & dataMean.milpVarCPU{m, j}(:, 2) < nBinmax * interval(k1, k2);
                    case 'Le'
                        select = select & dataMean.milpVarCPU{m, j}(:, 2) <= nBinmax * interval(k1, k2);
                end
            end
            val(k1, m, j) = sum(dataMean.milpVarCPU{m, j}(select, 1));
        end
    end
end
val = reshape(val, size(val, 1), size(val,2) * size(val,3))';
p2 = bar(x, val, 'stacked');

for k = 1:size(p2, 2)
    if BW
        p2(1,k).FaceColor = ((k-1)/(size(p2,2)-1)) * [1 1 1];
    end
    %             p(j,k).EdgeColor = 'none';
    p2(1,k).BarWidth = 0.6;
    %     p2(1,k).EdgeColor = 'none';
    p2(1,k).LineWidth = 0.1;
end
for k = 1:size(p, 2)
    if BW
        p(1,k).FaceColor = ((k-1)/(size(p,2)-1)) * [1 1 1];
    end
    p(1,k).BarWidth = 0.6;
    p(1,k).LineWidth = 0.1;
%     p(1,k).EdgeColor = 'none';
end

ax(2).YScale = 'log';
ax(2).YLim = 10.^[-1, 5];
ax(2).YTick = 10.^[-1:5];
ax(2).XLim = [0.0, x(end) + 1];
ax(2).XTick = x;
ax(2).XTickLabel = repmat(method2Test, 1, numel(testModel));
ax(2).XTickLabelRotation = 90;
%     ax(2).Position = [0.1 0.21 0.85, 0.55];
lg(2) = legend(leg2, 'interpreter','latex');

lg(2).Box = 'off';
ax(2).Box = 'off';
ax(2).YMinorTick = 'off';
ax(2).Color = 'none';
yl(2) = ylabel('MILP CPU time (sec)');
lg(1).Box = 'off';
ax(1).Position = [0.08 0.67 0.69 0.29];
ax(2).Position = [0.08 0.23 0.69 0.29];
lg(1).Position = [0.73 0.75 0.3 0.1];
lg(2).Position = [0.70 0.32 0.3 0.1];
f.Position = [10 10 8.5 6];
ax(3) = axes('Position',[0 0 1 1], 'visible', 'off');
mark(1) = text(0.01, 0.98, 'A', 'fontWeight' ,'bold', 'fontSize',14);
mark(2) = text(0.01, 0.53, 'B', 'fontWeight' ,'bold', 'fontSize',14);
mark(2).Position(2) = 0.54;

modelOrder = 1:7;%[1:3 5:7 4];
for j = 1:nModel
    t1 = strrep(strrep(modelName{modelOrder(j)},'.mat', ''),'_', ' ');
    if t1(1) == 'i'
        t1 = ['\textit{i}' t1(2:end)];
    end
    if strncmp(t1,'ecoli',5)
        t1 = strrep(t1, 'ecoli', '\textit{E. coli}');
    end
    tl(j,1) = text(0.6102*(j-1) / (nModel - 1) + 0.12, 0.07, t1,...
        'interpreter','latex');
    tl(j,2) = text(0.6102*(j-1) / (nModel - 1) + 0.12, 0.04, ...
        ['($|\bf{J}^{tic}|$ = ' num2str(max(dataMean.milpVarCPU{2, modelOrder(j)}(:, 2)))  ')'],'interpreter','latex');
    tl(j,1).HorizontalAlignment = 'center';
    tl(j,2).HorizontalAlignment = 'center';
    tl(j,1).FontSize = 13;
    tl(j,2).FontSize = 10.5;
end
tx = text(0.7971, 0.2775, '($f$ = reduction fraction)', 'interpreter', 'latex');
% tx.Position(1:2) = [33, 10^0.0];
map = colormap(ax(1),'jet');
m=[1 0.75 0.5; 1 0.75 0; 1 0.5 0; 1 0 0; 0.75 0 0.5; 0.5 0 0; 0.2 0.2 0.2];
colormap(ax(2),m([1 3 4 5 7],:))
colormap(ax(1),map(40:-1:13,:))

if 0
    %%
    if BW
        export_fig fig2 -png -transparent -r450
    else
        export_fig fig2_color -png -transparent -r300
    end
end
